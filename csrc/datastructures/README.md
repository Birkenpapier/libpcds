# Data Structures

This directory comprises various data structures that are fundamental for storing and managing data efficiently in a computer.

## Implemented Data Structures

- **Binary Tree**: A tree data structure in which each node has at most two children, referred to as the left child and the right child.
- **Bloom Filter**: A space-efficient probabilistic data structure that is used to test whether an element is a member of a set.
- **Fenwick Tree (Binary Indexed Tree)**: A data structure that provides efficient methods for calculation and manipulation of the prefix sums of a table of values.
- **Graphs**: Data structures that are used to represent a network of nodes (vertices) connected by edges.
- **Hash Table**: An implementation of a hash table data structure that maps keys to values for highly efficient lookup.
- **k-d Tree (2D)**: A space-partitioning data structure for organizing points in a k-dimensional space, particularly useful in applications such as range search and nearest neighbor search.
- **Library**: A sample data structure to represent a collection of books, CDs, or other items in a library.
- **Queue**: A FIFO (first in, first out) data structure.
- **Ring Buffer**: A circular buffer that is used for buffering data streams.
- **Segment Tree**: A tree data structure for storing intervals or segments, and allows querying which of the stored segments contain a given point.
- **Skip List**: A data structure that allows fast search within an ordered sequence of elements, faster than a linked list and simpler than a balanced tree.
- **Sparse Matrix**: A matrix in which most of the elements are zero, allowing for efficient representation and manipulation of the non-zero elements.
- **Stack**: A LIFO (last in, first out) data structure.
- **Suffix Array**: A sorted array of all suffixes of a string.
- **Trie**: A tree-like data structure that stores a dynamic set or associative array where the keys are usually strings.

Each data structure has its own unique properties and applications. Please look into the individual files for detailed explanations and specific use cases.
